// Generated by CoffeeScript 1.6.3
/*
	
		Model Driven View / Data Driven Template(s)
		
		https://github.com/qrpike/Model-Driven-View
		
		This is to help front end developers, define views with objects and templates
		and the view automatically re-render that view if the data inside of it changes.
		
		There are probably a few out there that do this, but this class uses Request Animation Frame
		to re-render all changes on a animation frame, so changing 5 attributes at once, wont trigger
		5 renders, it will trigger a render on the next animation frame. This speeds up rendering and 
		cuts back on un-needed renders dramatically.
		
		Created by: Quinton Pike
		Email: qrpike@gmail.com
*/

var ModelDrivenView,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ModelDrivenView = (function(_super) {
  __extends(ModelDrivenView, _super);

  /*
  		
  			Constructor for auto-rendering element:
  			
  			@param {Object} dataObject - Data which we are going to watch for changes, this is also passed into the template function.
  			@param {Function} template - Template function which renders the HTML form the @dataObject
  			@param {Object} container - DOM Element where this template is to render inside of. 
  			@param {Object} options - Options we want to change from default settings.
  */


  function ModelDrivenView(dataObject, template, container, options) {
    this.dataObject = dataObject;
    this.template = template;
    this.container = container;
    this.options = options != null ? options : {};
    this.render = __bind(this.render, this);
    this.getHTML = __bind(this.getHTML, this);
    this.reRender = __bind(this.reRender, this);
    this.createWatcher = __bind(this.createWatcher, this);
    this.autoRender = this.options.autoRender || true;
    this.append = this.options.appendOnInitialRender || true;
    this.renderOnInit = this.options.renderOnInit || true;
    this.el = null;
    if (this.autoRender) {
      this.createWatcher();
    }
    if (this.renderOnInit) {
      this.render();
    }
    this.needToRender = false;
  }

  ModelDrivenView.prototype.createWatcher = function() {
    var _this = this;
    return WatchJS.watch(this.dataObject, this.options.watchAttributes || {}, function() {
      /* 
      					If something changes, we set @needToRender = true.
      					The way we trigger a render is to just set this to TRUE. Once
      					we set this to true, next frame refresh on the browser it will render. 
      					This helps align the renders with the browsers refresh = better performance.
      */

      return _this.needToRender = true;
    });
  };

  ModelDrivenView.prototype.reRender = function() {
    var newEle;
    if (this.needToRender) {
      console.log('Rendering...');
      newEle = this.getHTML();
      this.el.replaceWith(newEle);
      this.el = newEle;
      this.emit('render', {
        el: this.el,
        rerender: true
      });
      this.needToRender = false;
    }
    /*
    				Loop this function every animation requested. Only do something when 
    				we actually need to render something again.
    */

    return window.requestAnimFrame(this.reRender);
  };

  ModelDrivenView.prototype.getHTML = function(jQueryObject) {
    if (jQueryObject == null) {
      jQueryObject = true;
    }
    if (jQueryObject) {
      return $(this.template(this.dataObject));
    } else {
      return this.template(this.dataObject);
    }
  };

  ModelDrivenView.prototype.render = function() {
    this.el = this.getHTML();
    if (this.append === true) {
      this.container.append(this.el);
    } else {
      this.container.html(this.el);
    }
    this.emit('render', {
      el: this.el,
      rerender: false
    });
    return this.reRender();
  };

  return ModelDrivenView;

})(EventEmitter);
